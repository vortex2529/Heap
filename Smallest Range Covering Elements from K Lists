class Node{
    public:
    int data;
    int row;
    int col;
    Node(int d,int r,int c):data(d),row(r),col(c){}
};

class compare{
    public:
    bool operator()(Node* a,Node* b){
        return a->data > b->data;
    }
};
class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        int mini = INT_MAX;
        int maxi = INT_MIN;
        priority_queue<Node*,vector<Node*>,compare> pq;

        for(int i=0;i<nums.size();i++){
            int element = nums[i][0];
            maxi = max(maxi,element);
            mini = min(mini,element);

            pq.push(new Node(element,i,0));
        }

        int ansStart = mini;
        int ansEnd = maxi;
        while(!pq.empty()){
            auto top = pq.top();
            pq.pop();
            int topData = top->data;
            int topRow = top->row;
            int topCol = top->col; 

            //update mini
            mini = topData; 

            // check for answer
            int currRange = maxi-mini;
            int ansRange = ansEnd-ansStart;
            if(currRange < ansRange){
                ansStart = mini;
                ansEnd = maxi;
            }
            if(topCol+1 < nums[topRow].size()){
               maxi = max(maxi,nums[topRow][topCol+1]); 
               pq.push(new Node(nums[topRow][topCol+1],topRow,topCol+1));
                
            }
            else{
                break;
            }
        }
        return {ansStart,ansEnd};
    }
};
