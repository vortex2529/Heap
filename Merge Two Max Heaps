// Brute Force 

class Solution {
  public:
    vector<int> mergeHeaps(vector<int> &a, vector<int> &b, int n, int m) {

        priority_queue<int> pq;
        
        for(auto e:a) pq.push(e);
        for(auto e:b) pq.push(e);
        
        vector<int> ans;
        
        while(!pq.empty()){
            ans.push_back(pq.top());
            pq.pop();
        }
        
        return ans;
    }
}; 


// Optimal 

class Solution {
  public:
    void heapify(vector<int> &arr,int n,int i){
        int index= i;
        int left = 2*index+1;
        int right = 2*index + 2;
        
        int largest = index;
        
        if(left < n && arr[largest] < arr[left]){
            largest = left;
        }
        if(right < n && arr[largest] < arr[right]){
            largest = right;
        }
        
        if(largest != index){
            swap(arr[index],arr[largest]);
            index = largest;
            heapify(arr,n,index);
        }
    }
    
    void buildHeap(vector<int> &arr,int n){
        for(int i=n/2-1;i>=0;i--){
            heapify(arr,n,i);
        }
    }
    vector<int> mergeHeaps(vector<int> &a, vector<int> &b, int n, int m) {

        int size = n+m;
        vector<int> ans(size);
        
        int i=0;
        int j=0;
        while(j<n){
            ans[i++] = a[j++];
        }
        
        j=0;
        while(j<m){
            ans[i++]=b[j++];
        }
        
        buildHeap(ans,size);
        
        return ans;
    }
};
